{"/code-place/developer/infra/kustomize/":{"data":{"":"이 문서에서는 Kustomize의 기본 개념과 코드플레이스 내에서의 활용 방법에 대해 설명합니다. 코드플레이스를 각 환경에 맞게 릴리즈하고 관리하는 방법도 포함되어 있습니다. Kustomize는 쿠버네티스 리소스의 선언적 관리를 위한 도구로, YAML 파일을 조작하고 구성하는 데 사용됩니다. 코드플레이스에서는 Kustomize를 사용하여 각 환경(개발, 프로덕션 등)에 맞게 쿠버네티스 리소스를 커스터마이징하고 있습니다.","1-개발dev-환경에-배포하기#1. 개발(dev) 환경에 배포하기":"개발 환경에 배포하려면, kubernetes/overlays/dev 디렉토리를 대상으로 kubectl apply -k 명령어를 실행합니다. 이 명령어는 code-place-dev 네임스페이스에 리소스를 배포합니다.\nkubectl apply -k kubernetes/overlays/dev","1-리소스-취합-resources#1. 리소스 취합 (\u003ccode\u003eresources\u003c/code\u003e)":"Kustomize는 빌드를 시작할 때 resources 필드에 정의된 모든 YAML 파일을 불러옵니다.\n../../base: 모든 환경의 기반이 되는 공통 base 리소스(Deployment, Service 등)를 모두 가져옵니다. ./secrets/*.yaml: prod 환경에만 필요한 추가 리소스, 즉 환경별 인증 정보(SealedSecret)를 가져옵니다. 이 과정을 거치면, Kustomize는 base와 overlay의 모든 리소스를 하나의 큰 집합으로 취합합니다.","2-패치-적용-및-수정-patches#2. 패치 적용 및 수정 (\u003ccode\u003epatches\u003c/code\u003e)":"이 단계가 Kustomize 커스터마이징의 핵심입니다. patches에 정의된 파일들은 base 리소스를 어떻게 수정할지 명시합니다.\nKustomize는 Strategic Merge Patch 방식을 사용하여 base 리소스 위에 patch 파일의 내용을 덮어씁니다. 이름(metadata.name)을 기준으로 원본 리소스를 찾아 변경할 필드만 정확히 수정합니다.","2-프로덕션prod-환경에-배포하기#2. 프로덕션(prod) 환경에 배포하기":"개발 환경과 동일한 방식이지만, 대상 디렉토리를 prod로 변경하면 됩니다. 이 명령어는 code-place-prod 네임스페이스에 리소스를 배포합니다.\nkubectl apply -k kubernetes/overlays/prod 배포 전 최종 설정 확인\n특히 프로덕션 환경에 배포하기 전에는 어떤 변경사항이 적용될지 미리 확인하는 것이 안전합니다. kubectl apply를 실행하기 전에 다음 명령어로 최종 생성될 YAML 파일을 검토할 수 있습니다.\n# prod 환경의 최종 YAML을 터미널에 출력하여 확인 kustomize build kubernetes/overlays/prod","3-최종-매니페스트-생성#3. 최종 매니페스트 생성":"모든 patch와 namespace 적용이 끝나면, Kustomize는 모든 리소스가 조합되고 수정된 최종 매니페스트를 생성합니다. 이 결과물은 클러스터에 바로 적용할 수 있는 완전한 상태가 됩니다.","kustomize-기본-개념#Kustomize 기본 개념":"Kustomize를 이해하기 위해서는 base와 overlay 개념을 알아야 합니다.\nBase: 모든 환경에서 공통적으로 사용되는 리소스의 원본 정의를 포함하는 디렉토리입니다. 예를 들어, 애플리케이션의 기본 배포(Deployment)나 서비스(Service) 설정이 여기에 포함됩니다. Overlay: 특정 환경에 맞게 base의 설정을 덮어쓰거나 변경(patch)하는 디렉토리입니다. 예를 들어, 개발 환경에서는 리소스 요청을 낮게 설정하고, 프로덕션 환경에서는 더 높은 설정을 적용하는 등의 차이를 관리합니다. 정리하면, base에서 환경에 독립적인 리소스를 정의하고, overlay에서 환경별로 필요한 변경 사항을 적용하는 방식입니다.","kustomize의-동작-원리-base와-overlay#Kustomize의 동작 원리: Base와 Overlay":"Kustomize는 kustomization.yaml 파일 하나로 base와 overlay를 연결합니다. 이 파일은 base의 공통 리소스를 가져와 overlay의 차이점을 덧씌우는(patch) 역할을 합니다.\n코드플레이스의 prod 환경 kustomization.yaml을 예시로 이 과정을 단계별로 설명하겠습니다.\n# kubernetes/overlays/prod/kustomization.yaml apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization resources: - ../../base - ./secrets/pg-credentials.yaml - ./secrets/regcred.yaml - ./secrets/common-credentials.yaml namespace: code-place-prod patches: - path: backend-deployment-patch.yaml - path: frontend-deployment-patch.yaml # ... 등등","각-환경별-릴리즈-방법#각 환경별 릴리즈 방법":"Kustomize는 간단한 명령어로 특정 환경에 맞는 최종 쿠버네티스 매니페스트를 생성하고, 이를 kubectl로 클러스터에 바로 적용할 수 있게 해줍니다.","예시-replicas-수-변경#예시: \u003ccode\u003ereplicas\u003c/code\u003e 수 변경":"base의 backend-deployment.yaml은 기본적으로 replicas를 2로 설정합니다.\n# kubernetes/base/backend/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: backend spec: replicas: 2 ... prod 환경에서는 더 많은 트래픽을 감당해야 하므로, overlays/prod의 backend-deployment-patch.yaml에 변경할 부분만 다음과 같이 명시합니다.\n# kubernetes/overlays/prod/backend-deployment-patch.yaml apiVersion: apps/v1 kind: Deployment metadata: name: backend spec: replicas: 6 kustomize build 시, Kustomize는 base의 Deployment 중 이름이 backend인 리소스를 찾아 spec.replicas 값을 6으로 덮어씁니다. 이미지 태그, 도메인 이름 등 다른 모든 커스터마이징도 이와 동일한 원리로 동작합니다."},"title":"Kustomize 기반 리소스 정의 및 릴리즈"},"/code-place/developer/infra/traefik-tls/":{"data":{"":"이 문서에서는 Traefik이 TLS 인증서 발급을 담당하도록 하는 방법과, 새로운 Ingress에 TLS 인증을 추가하는 방법에 대해 설명합니다. 웹페이지에서 HTTP가 아닌 HTTPS로 접근하기 위해서는 주기적인 TLS 인증서 발급이 필수입니다.\n코드플레이스는 Traefik에 내장되어 있는 Let's Encrypt를 통해 인증서를 발급받고 있습니다. 그 이유는 크게 다음과 같습니다.\nIngress를 구성할 때 단 몇 줄의 코드로 TLS 인증서를 발급받을 수 있습니다. Traefik이 인증서 만료일을 추적하고, 30일 이내인 인증서를 자동으로 갱신해줍니다.","ingress에-tls-인증서-추가하기#Ingress에 TLS 인증서 추가하기":"Traefik 설정이 완료되었다면, Ingress 리소스에 몇 가지 annotation과 tls 설정을 추가하는 것만으로 간단하게 HTTPS를 적용할 수 있습니다.\n다음은 frontend-ingress에 prod 환경의 도메인(code.pusan.ac.kr)을 위한 TLS 인증서를 적용하는 예시입니다.\n기본 Ingress 정의 (kubernetes/base/frontend/ingress.yaml)\n# kubernetes/base/frontend/ingress.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: frontend-ingress annotations: # 이 Ingress를 Traefik이 관리하도록 지정 kubernetes.io/ingress.class: traefik # 'default'라는 이름의 Certificate Resolver를 사용해 TLS 인증서를 발급 traefik.ingress.kubernetes.io/router.tls.certresolver: default # NOTE: 호스트 및 경로 설정은 패치 파일에서 관리됩니다. 환경별 Ingress 패치 (kubernetes/overlays/prod/frontend-ingress-patch.yaml)\n# kubernetes/overlays/prod/frontend-ingress-patch.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: frontend-ingress spec: rules: # 어떤 호스트 이름으로 요청이 들어올 때 적용할지 정의 - host: code.pusan.ac.kr http: paths: - path: / pathType: Prefix backend: service: name: frontend port: number: 80 # TLS를 적용할 호스트 목록을 명시 tls: - hosts: - code.pusan.ac.kr","traefik-인증서-발급-설정#Traefik 인증서 발급 설정":"K3s 클러스터에 설치된 Traefik의 Let’s Encrypt 연동 설정은 kubernetes/setup/traefik/traefik-config.yaml 파일에서 관리됩니다. 이 파일은 K3s가 기본으로 설치하는 Traefik Helm Chart의 설정을 덮어씁니다.\n# kubernetes/setup/traefik/traefik-config.yaml apiVersion: helm.cattle.io/v1 kind: HelmChartConfig metadata: name: traefik namespace: kube-system spec: valuesContent: |- additionalArguments: - \"--certificatesresolvers.default.acme.email=\" - \"--certificatesresolvers.default.acme.storage=/data/acme.json\" - \"--certificatesresolvers.default.acme.tlschallenge=true\" # 443 포트를 통해 인증 # ... (중략) ... persistence: enabled: true name: data accessMode: ReadWriteMany # 여러 노드에서 읽기/쓰기가 가능하도록 설정 size: 128Mi storageClass: \"longhorn\" path: /data deployment: initContainers: - name: volume-permissions image: busybox:latest command: - \"sh\" - \"-c\" - | touch /data/acme.json chmod 600 /data/acme.json chown 65532:65532 /data/acme.json volumeMounts: - name: data mountPath: /data podSecurityContext: fsGroup: 65532","설정-단계-요약#설정 단계 요약":"새로운 서비스에 TLS 인증서를 발급하려면 다음과 같이 Ingress 리소스를 작성하면 됩니다.\nmetadata.annotations에 traefik.ingress.kubernetes.io/router.tls.certresolver: default를 추가하여 Let’s Encrypt 자동 발급 기능을 활성화합니다. spec.rules에 TLS를 적용할 host를 정의합니다. spec.tls 블록에 host와 동일한 도메인 이름을 추가합니다. 이렇게 설정된 Ingress가 클러스터에 배포되면, Traefik은 tls 블록에 명시된 host를 감지하고, certresolver 설정을 따라 Let’s Encrypt에 해당 도메인의 TLS 인증서를 요청합니다. 발급이 완료되면 자동으로 해당 인증서를 적용하여 HTTPS 트래픽을 처리합니다.","주요-설정-항목#주요 설정 항목":"additionalArguments: Traefik의 동작을 설정하는 핵심 인자입니다. --certificatesresolvers.default.acme.email: Let’s Encrypt 계정으로 사용할 이메일 주소입니다. 인증서 만료 알림 등을 받을 때 사용됩니다. --certificatesresolvers.default.acme.storage: 발급된 TLS 인증서와 개인키가 저장될 경로입니다. acme.json 파일에 모든 정보가 기록됩니다. --certificatesresolvers.default.acme.tlschallenge=true: 도메인 소유권을 증명하는 ACME Challenge 방식으로 TLS-AL-01을 사용하도록 설정합니다. 이 방식은 443 포트를 통해 이루어지므로, 웹 트래픽과 동일한 포트를 사용하여 방화벽 관리가 용이합니다. persistence: acme.json 파일을 영구적으로 보관하기 위한 설정입니다. Traefik 파드가 재시작되더라도 인증서 정보가 유실되지 않도록 PersistentVolumeClaim을 사용합니다. 코드플레이스에서는 longhorn 스토리지 클래스를 통해 PVC를 생성합니다. deployment.initContainers: acme.json 파일의 권한 문제를 해결하기 위한 설정입니다. Traefik은 보안상의 이유로 non-root 유저(UID 65532)로 실행됩니다. initContainer는 메인 컨테이너가 시작되기 전에 실행되어 acme.json 파일이 존재하도록 보장하고, 파일 권한을 600으로, 소유자를 65532로 설정하여 Traefik 프로세스가 안전하게 파일에 접근할 수 있도록 합니다."},"title":"Traefik TLS 설정"}}